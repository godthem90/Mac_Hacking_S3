/** \file
 * Read arbitrary physical memory.
 *
 * This is not as dangerous as wrmem, but you should still be careful!
 * For instance, attempting to read from SMRAM will cause an immediate
 * kernel panic.
 *
 * (c) 2015 Trammell Hudson
 */
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <strings.h>
#include <ctype.h>
#include <unistd.h>
#include "DirectHW.h"

#define BOOT_SCRIPT_EDK_SIGN			'\xAA'
#define BOOT_SCRIPT_TABLE_HEADER_LEN	0x34

#define EFI_BOOT_SCRIPT_IO_WRITE_OPCODE 				0x00
#define EFI_BOOT_SCRIPT_IO_READ_WRITE_OPCODE			0x01
#define EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE				0x02
#define EFI_BOOT_SCRIPT_MEM_READ_WRITE_OPCODE			0x03
#define EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE 		0x04
#define	EFI_BOOT_SCRIPT_PCI_CONFIG_READ_WRITE_OPCODE	0x05
#define	EFI_BOOT_SCRIPT_SMBUS_EXECUTE_OPCODE			0x06
#define	EFI_BOOT_SCRIPT_STALL_OPCODE					0x07
#define	EFI_BOOT_SCRIPT_DISPATCH_OPCODE					0x08
#define	EFI_BOOT_SCRIPT_MEM_POLL_OPCODE					0x09

char bootscript_opcode[10][50] =	{	"EFI_BOOT_SCRIPT_IO_WRITE_OPCODE", "EFI_BOOT_SCRIPT_IO_READ_WRITE_OPCODE",
								"EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE", "EFI_BOOT_SCRIPT_MEM_READ_WRITE_OPCODE",
								"EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE", "EFI_BOOT_SCRIPT_PCI_CONFIG_READ_WRITE_OPCODE",
								"EFI_BOOT_SCRIPT_SMBUS_EXECUTE_OPCODE", "EFI_BOOT_SCRIPT_STALL_OPCODE",
								"EFI_BOOT_SCRIPT_DISPATCH_OPCODE", "EFI_BOOT_SCRIPT_MEM_POLL_OPCODE"	};


static char printable( uint8_t c )
{
	if (isprint(c))
		return (char) c;
	return '.';
}

static void hexdump( const uintptr_t base_offset, const uint8_t * const buf, const size_t len )
{
	const size_t width = 16;

	for (size_t offset = 0 ; offset < len ; offset += width)
	{
		printf("%08"PRIxPTR":", base_offset + offset);
		for (size_t i = 0 ; i < width ; i++)
		{
			if (i + offset < len)
				printf(" %02x", buf[offset+i]);
			else
				printf("   ");
		}

		printf("  ");

		for (size_t i = 0 ; i < width ; i++)
		{
			if (i + offset < len)
				printf("%c", printable(buf[offset+i]));
			else
				printf(" ");
		}

		printf("\n");
	}
}


/*
 * Copy four bytes at a time, even if it spills over.
 * This will read from the PCI space safely, unlike mempcy().
 */
static void quad_memcpy( uint32_t * const out, const uint32_t * const in, size_t len)
{
	for (size_t i = 0 ; i < len ; i += 4)
	{
		out[i/4] = in[i/4];
	}
}

int get_physical_map( uintptr_t addr, size_t len, void *out_buf )
{

	// align to a page boundary
	const uintptr_t page_mask = 0xFFF;
	const uintptr_t page_offset = addr & page_mask;
	const uintptr_t map_addr = addr & ~page_mask;
	const size_t map_len = (len + page_offset + page_mask) & ~page_mask;

	const uint8_t * const map_buf = map_physical(map_addr, map_len);
	if (map_buf == NULL)
	{
		perror("mmap");
		return EXIT_FAILURE;
	}

	const uint8_t * const buf = map_buf + page_offset;

	// because the PCIe space doesn't like being probed at anything
	// other than 4-bytes at a time, we force a copy of the region
	// into a local buffer.


	quad_memcpy(out_buf, (const void*) buf, len);
	return EXIT_SUCCESS;
}

int parse_bootscript( void * bootscript )
{
	void *bs_descriptor = bootscript;;

	if( (*(char *)bs_descriptor++) == BOOT_SCRIPT_EDK_SIGN )
	{
		printf("This is EDK Boot Script\n");

		bs_descriptor += BOOT_SCRIPT_TABLE_HEADER_LEN;
		uint16_t op = 0;
		uint8_t size = 0;
		uint32_t width = 0;
		uint32_t count = 0;
		uint64_t addr = 0;
		uint32_t val = 0;

		while( op != 0xff )
		{
			op = *(uint16_t *)bs_descriptor;
			size = *(uint8_t *)(bs_descriptor+0x2);
			printf("opcode : %s, size : %d\n", bootscript_opcode[op], size);
            if( op == EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE )
			{
                width = *(uint32_t *)(bs_descriptor+0x3);
				count = *(uint32_t *)(bs_descriptor+0x7);
                addr = *(uint64_t *)(bs_descriptor+0xb);
				printf("width : 0x%x, count : 0x%x, addr : 0x%x\n", width, count, addr);
				int i;
				for( i = 0; i < size; i++)
					printf("%02x ", *(uint8_t *)(bs_descriptor+i));
				printf("\n\n");
			}
			else if( op == EFI_BOOT_SCRIPT_MEM_READ_WRITE_OPCODE )
			{
                width = *(uint32_t *)(bs_descriptor+0x3);
                addr = *(uint64_t *)(bs_descriptor+0x7);
				printf("width : 0x%x, addr : 0x%x\n", width, addr);
				int i;
				for( i = 0; i < size; i++)
					printf("%02x ", *(uint8_t *)(bs_descriptor+i));
				printf("\n\n");
			}
			else if( op == EFI_BOOT_SCRIPT_MEM_POLL_OPCODE )
			{
				int i;
				for( i = 0; i < size; i++)
					printf("%02x ", *(uint8_t *)(bs_descriptor+i));
				printf("\n\n");
                /*width = *(uint32_t *)(bs_descriptor+0x3);
                addr = *(uint64_t *)(bs_descriptor+0x7);
				duration = *(uint64_t *)(bs_descriptor+0xf);
				loop = *(uint64_t *)(bs_descriptor+0x17)
				printf("width : 0x%x, count : 0x%x, addr : 0x%x\n\n", width, count, addr);*/
			}
			else if( op == EFI_BOOT_SCRIPT_IO_READ_WRITE_OPCODE )
			{
                width = *(uint32_t *)(bs_descriptor+0x3);
				printf("width : 0x%x\n\n", width);
			}
            /*else if( op == EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE )
			{
                width, count = byte_at(data, 9), qword_at(data, 24)
                addr = qword_at(data, 16)
                bus, dev, fun, off = (addr >> 24) & 0xff, (addr >> 16) & 0xff, \
                                     (addr >> 8) & 0xff,  (addr >> 0) & 0xff
                values = self.read_values(data[32:], width, count)
                self.process_pci_config_write(width, bus, dev, fun, off, count, values)
			}*/
            /*else if( op == EFI_BOOT_SCRIPT_IO_WRITE_OPCODE )
			{
                width, count = byte_at(data, 9), qword_at(data, 16)
                port = word_at(data, 10)
                values = self.read_values(data[24:], width, count)
                self.process_io_write(width, port, count, values)
			}*/
            else if( op == EFI_BOOT_SCRIPT_DISPATCH_OPCODE )
			{
                addr = *(uint64_t *)(bs_descriptor+0x3);
                printf("addr : 0x%x\n\n", addr);
			}

			bs_descriptor += size;
		}
	}
	else
		printf("This is Intel Boot Script\n");

	return 0;
}

int main( int argc, char ** argv )
{
	int do_ascii = 0;

	if (iopl(0) < 0)
	{
		perror("iopl");
		return EXIT_FAILURE;
	}

	uintptr_t addr = 0x8cf8b000;
	size_t len = 0x20;
	void *out_buf = calloc(1, len);
	if (!out_buf)
	{
		perror("calloc");
		return EXIT_FAILURE;
	}
	get_physical_map(addr, len, out_buf);

	addr = ((uintptr_t *)out_buf)[0x3];
	len = 0x8000;
	free(out_buf);
	out_buf = calloc(1, len);
	if (!out_buf)
	{
		perror("calloc");
		return EXIT_FAILURE;
	}
	get_physical_map(addr, len, out_buf);

	parse_bootscript( out_buf );

	free( out_buf );

	/*
	   dispatch_addr = self.CustomBootScriptParser(quiet = True).parse(
	   data, boot_script_addr = boot_script);

	   if dispatch_addr is None: raise Exception('Unable to locate EFI_BOOT_SCRIPT_DISPATCH_OPCODE')

	   print '[*] Target function addr = 0x%x' % dispatch_addr
	 */
	/*
	   if (do_ascii)
	   {
	   hexdump(addr, out_buf, len);
	   } else {
	   for(size_t offset = 0 ; offset < len ; )
	   {
	   const ssize_t rc = write(
	   STDOUT_FILENO,
	   out_buf + offset,
	   len - offset
	   );

	   if (rc <= 0)
	   {
	   perror("write");
	   return EXIT_FAILURE;
	   }

	   offset += rc;
	   }
	   }
	 */

	return EXIT_SUCCESS;
}
